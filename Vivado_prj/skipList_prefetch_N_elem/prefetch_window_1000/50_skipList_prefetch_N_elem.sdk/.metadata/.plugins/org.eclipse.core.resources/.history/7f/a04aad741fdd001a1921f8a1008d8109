/*
 * LinkList.h
 *
 *  Created on: 13-Aug-2020
 *      Author: Haresh Prasannha
 */

#ifndef SRC_LINKLIST_H_
#define SRC_LINKLIST_H_

#include <stdlib.h>
#include <stdio.h>

#define skip_intr 10

typedef void * dat_typ1;
typedef int dat_typ2;

struct node {
    dat_typ1 val;
    dat_typ2 offs[2];
};

struct node *head = NULL;

struct node *next(struct node *ip_node){
    return (ip_node + ip_node->offs[0]);
};

void print_list(){
    struct node *temp  = head;
	struct node *old_temp = NULL;
	while(temp != old_temp){
		old_temp = temp;
		printf("Val: %d-->",*((int *)temp->val));
		temp = next(temp);
		printf("next_node_1: %d  ",*((int *)temp->val));
		temp = old_temp+old_temp->offs[1];
		printf("next_node_2: %d  ",*((int *)temp->val));
		temp = next(old_temp);
		printf("\n");
	}
}

void skip_list(){
    struct node *curr_node = head;
    struct node *skip_prevnode = head;
    int i=0;
    int exit_flag=0;
    while (!exit_flag){
        if ((i+1)%skip_intr == 0){
            skip_prevnode->offs[1] = (curr_node - skip_prevnode);
			skip_prevnode = curr_node;
        }
        else
            curr_node->offs[1] = 0;
        i=i+1;
        if (curr_node->offs[0] == 0){
            exit_flag = 1;
        }
        else{
            exit_flag = 0;
        }
        curr_node = next(curr_node);
    }
}

int insert(int *list_elem, int *new_elem){
    int status;
    int elem_found = 0;
    struct node *newnode = (struct node *)malloc(sizeof(struct node));
    struct node *prevnode = NULL;
    struct node *curr_node = NULL;
    struct node *nxt_node = NULL;
	newnode->val = new_elem;
	newnode->offs[0] = 0;
    newnode->offs[1] = 0;
    if (head == NULL){
        head = newnode;
        status = 1;
    }
    else{
        curr_node = head;
        while (curr_node->offs[0] != 0 ){
            if (*((int *)curr_node->val) == *((int *)list_elem)){
                elem_found = 1;
                break;
            }
            else{
                curr_node = next(curr_node);
                elem_found = 2;
            }
        }
        if (elem_found == 1){
            nxt_node = next(curr_node);
            curr_node->offs[0] = (newnode - curr_node);
            newnode->offs[0] = (nxt_node - newnode);
            status = 1;
        }
        else if (elem_found == 2 && (*((int *)curr_node->val) != *list_elem)){
            printf("Element %d not present in list\n",*list_elem);
            status = 0;
        }
        else{
            curr_node->offs[0] = (newnode - curr_node);
            newnode->offs[0] = 0;
            status = 1;
        }
        skip_list();
    }
    return status;
}

int remove(int elem){
    int status;
    struct node *curr_node = head;
    struct node *nxt_node = NULL;
    struct node *prev_node = NULL;
    int exit_flag = 0;
    int elem_found = 0;
    while(!exit_flag){
        if (*((int *)curr_node->val) == elem){
            nxt_node = next(curr_node);
            elem_found = 1;
            break;
        }
        if (curr_node->offs[0] == 0)
            exit_flag = 1;
        else{
            exit_flag = 0;
            prev_node = curr_node;
            curr_node = next(curr_node);
        }
    }
    if (elem_found){
        if (curr_node == head)
            head = nxt_node;
        else if (nxt_node == curr_node)
            prev_node->offs[0] = 0;
        else
            prev_node->offs[0] = (nxt_node - prev_node);
        skip_list();
        status = 1;
    }
    else{
        printf("Element %d not present in list\n",elem);
        status = 0;
    }
    return status;
}




#endif /* SRC_LINKLIST_H_ */
